package formatter

import (
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/dave/dst"
	"github.com/samber/lo"
	"golang.org/x/mod/modfile"
)

func detectGoVersion(filePath string) string {
	modPath := findGoMod(filePath)
	if modPath == "" {
		return ""
	}

	data, err := os.ReadFile(modPath)
	if err != nil {
		return ""
	}

	mf, err := modfile.Parse(modPath, data, nil)
	if err != nil || mf.Go == nil {
		return ""
	}

	return "go" + mf.Go.Version
}

func findConstructorType(fn *dst.FuncDecl, typeNames map[string]bool) string {
	if fn.Type.Results == nil || len(fn.Type.Results.List) == 0 {
		return ""
	}

	for _, result := range fn.Type.Results.List {
		typeName := extractTypeName(result.Type)
		if typeName == "" || !typeNames[typeName] {
			continue
		}
		if matchesConstructorPattern(fn.Name.Name, typeName) {
			return typeName
		}
	}

	return ""
}

func getExportGroup(name string) int {
	switch {
	case name == "_":
		return 0
	case isExported(name):
		return 1
	default:
		return 2
	}
}

func getFieldTypeName(field *dst.Field) string {
	return extractTypeName(field.Type)
}

func getReceiverTypeName(fn *dst.FuncDecl) string {
	if fn.Recv == nil || len(fn.Recv.List) == 0 {
		return ""
	}

	return extractTypeName(fn.Recv.List[0].Type)
}

func getSpecExportGroup(vs *dst.ValueSpec) int {
	if len(vs.Names) == 0 {
		return 0
	}
	name := vs.Names[0].Name
	switch {
	case name == "_":
		return 0
	case isExported(name):
		return 1
	default:
		return 2
	}
}

func hasIota(d *dst.GenDecl) bool {
	for _, spec := range d.Specs {
		vs, ok := spec.(*dst.ValueSpec)
		if !ok {
			continue
		}
		for _, val := range vs.Values {
			if containsIota(val) {
				return true
			}
		}
	}

	return false
}

func isFuncInterface(iface *dst.InterfaceType) bool {
	return iface.Methods != nil && len(iface.Methods.List) == 1 && isFuncType(iface.Methods.List[0].Type)
}

func addSpaceBeforeReturns(f *dst.File) {
	dst.Inspect(f, func(n dst.Node) bool {
		block, ok := n.(*dst.BlockStmt)
		if !ok || len(block.List) < 2 {
			return true
		}
		for i, stmt := range block.List {
			if i == 0 {
				continue
			}
			if _, isReturn := stmt.(*dst.ReturnStmt); isReturn {
				if stmt.Decorations().Before != dst.EmptyLine {
					stmt.Decorations().Before = dst.EmptyLine
				}
			}
		}

		return true
	})
}

func containsIota(expr dst.Expr) bool {
	switch e := expr.(type) {
	case *dst.Ident:
		return e.Name == "iota"
	case *dst.BinaryExpr:
		return containsIota(e.X) || containsIota(e.Y)
	case *dst.UnaryExpr:
		return containsIota(e.X)
	case *dst.ParenExpr:
		return containsIota(e.X)
	case *dst.CallExpr:
		for _, arg := range e.Args {
			if containsIota(arg) {
				return true
			}
		}
	}

	return false
}

func expandOneLineFunctions(f *dst.File) {
	dst.Inspect(f, func(n dst.Node) bool {
		fn, ok := n.(*dst.FuncDecl)
		if !ok || fn.Body == nil || len(fn.Body.List) == 0 {
			return true
		}
		fn.Body.List[0].Decorations().Before = dst.NewLine

		return true
	})
}

func extractTypeName(expr dst.Expr) string {
	switch t := expr.(type) {
	case *dst.Ident:
		return t.Name
	case *dst.StarExpr:
		return extractTypeName(t.X)
	case *dst.SelectorExpr:
		return t.Sel.Name
	case *dst.IndexExpr:
		return extractTypeName(t.X)
	case *dst.IndexListExpr:
		return extractTypeName(t.X)
	}

	return ""
}

func findGoMod(filePath string) string {
	dir := filepath.Dir(filePath)
	for {
		goModPath := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(goModPath); err == nil {
			return goModPath
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}

	return ""
}

func getSpecFirstName(spec dst.Spec) string {
	switch s := spec.(type) {
	case *dst.ValueSpec:
		if len(s.Names) > 0 {
			return s.Names[0].Name
		}
	case *dst.TypeSpec:
		return s.Name.Name
	}

	return ""
}

func isBlankVarSpec(spec dst.Spec) bool {
	vs, ok := spec.(*dst.ValueSpec)
	if !ok {
		return false
	}

	return lo.ContainsBy(vs.Names, func(name *dst.Ident) bool {
		return name.Name == "_"
	})
}

func isExported(name string) bool {
	return len(name) > 0 && unicode.IsUpper(rune(name[0]))
}

func isFuncType(expr dst.Expr) bool {
	_, ok := expr.(*dst.FuncType)

	return ok
}

func isGeneratedFile(f *dst.File) bool {
	if len(f.Decs.Start) == 0 {
		return false
	}
	firstComment := f.Decs.Start[0]

	return strings.HasPrefix(firstComment, "// Code generated") ||
		strings.HasPrefix(firstComment, "// DO NOT EDIT") ||
		strings.HasPrefix(firstComment, "// GENERATED") ||
		strings.HasPrefix(firstComment, "// Autogenerated") ||
		strings.HasPrefix(firstComment, "// auto-generated") ||
		strings.HasPrefix(firstComment, "// Automatically generated")
}

func matchesConstructorPattern(funcName, typeName string) bool {
	var suffix string
	if strings.HasPrefix(funcName, "New") {
		suffix = strings.TrimPrefix(funcName, "New")
	} else if strings.HasPrefix(funcName, "new") {
		suffix = strings.TrimPrefix(funcName, "new")
	} else {
		return false
	}

	if strings.EqualFold(suffix, typeName) {
		return true
	}
	if len(suffix) > len(typeName) && strings.EqualFold(suffix[:len(typeName)], typeName) {
		nextChar := rune(suffix[len(typeName)])

		return !unicode.IsLower(nextChar)
	}

	return false
}

func normalizeSpacing(f *dst.File) {
	dst.Inspect(f, func(n dst.Node) bool {
		if n == nil {
			return false
		}
		switch d := n.(type) {
		case *dst.GenDecl:
			if d.Decs.Before > dst.EmptyLine {
				d.Decs.Before = dst.EmptyLine
			}
		case *dst.FuncDecl:
			if d.Decs.Before > dst.EmptyLine {
				d.Decs.Before = dst.EmptyLine
			}
		case *dst.Field:
			if d.Decs.Before > dst.EmptyLine {
				d.Decs.Before = dst.EmptyLine
			}
		}

		return true
	})
}
