package formatter

import (
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/dave/dst"
	"golang.org/x/mod/modfile"
)

func detectGoVersion(filePath string) string {
	dir := filepath.Dir(filePath)
	for {
		goModPath := filepath.Join(dir, "go.mod")
		if data, err := os.ReadFile(goModPath); err == nil {
			if mf, err := modfile.Parse(goModPath, data, nil); err == nil && mf.Go != nil {
				return "go" + mf.Go.Version
			}
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}

	return ""
}

func isGeneratedFile(f *dst.File) bool {
	if len(f.Decs.Start) == 0 {
		return false
	}
	firstComment := f.Decs.Start[0]

	return strings.HasPrefix(firstComment, "// Code generated") ||
		strings.HasPrefix(firstComment, "// DO NOT EDIT") ||
		strings.HasPrefix(firstComment, "// GENERATED") ||
		strings.HasPrefix(firstComment, "// Autogenerated") ||
		strings.HasPrefix(firstComment, "// auto-generated") ||
		strings.HasPrefix(firstComment, "// Automatically generated")
}

func isExported(name string) bool {
	return len(name) > 0 && unicode.IsUpper(rune(name[0]))
}

func getExportGroup(name string) int {
	switch {
	case name == "_":
		return 0
	case isExported(name):
		return 1
	default:
		return 2
	}
}

func getSpecExportGroup(vs *dst.ValueSpec) int {
	if len(vs.Names) == 0 {
		return 0
	}
	name := vs.Names[0].Name
	switch {
	case name == "_":
		return 0
	case isExported(name):
		return 1
	default:
		return 2
	}
}

func getSpecFirstName(spec dst.Spec) string {
	switch s := spec.(type) {
	case *dst.ValueSpec:
		if len(s.Names) > 0 {
			return s.Names[0].Name
		}
	case *dst.TypeSpec:
		return s.Name.Name
	}

	return ""
}

func getFieldTypeName(field *dst.Field) string {
	return extractTypeName(field.Type)
}

func getReceiverTypeName(fn *dst.FuncDecl) string {
	if fn.Recv == nil || len(fn.Recv.List) == 0 {
		return ""
	}

	return extractTypeName(fn.Recv.List[0].Type)
}

func extractTypeName(expr dst.Expr) string {
	switch t := expr.(type) {
	case *dst.Ident:
		return t.Name
	case *dst.StarExpr:
		return extractTypeName(t.X)
	case *dst.SelectorExpr:
		return t.Sel.Name
	case *dst.IndexExpr:
		return extractTypeName(t.X)
	case *dst.IndexListExpr:
		return extractTypeName(t.X)
	}

	return ""
}

func findConstructorType(fn *dst.FuncDecl, typeNames map[string]bool) string {
	if fn.Type.Results == nil || len(fn.Type.Results.List) == 0 {
		return ""
	}

	for _, result := range fn.Type.Results.List {
		typeName := extractTypeName(result.Type)
		if typeName == "" || !typeNames[typeName] {
			continue
		}
		if matchesConstructorPattern(fn.Name.Name, typeName) {
			return typeName
		}
	}

	return ""
}

func matchesConstructorPattern(funcName, typeName string) bool {
	suffix := strings.TrimPrefix(funcName, "New")
	if suffix == typeName {
		return true
	}
	if strings.HasPrefix(suffix, typeName) && len(suffix) > len(typeName) {
		nextChar := rune(suffix[len(typeName)])

		return !unicode.IsLower(nextChar)
	}

	return false
}

func normalizeSpacing(f *dst.File) {
	dst.Inspect(f, func(n dst.Node) bool {
		if n == nil {
			return false
		}
		switch d := n.(type) {
		case *dst.GenDecl:
			if d.Decs.Before > dst.EmptyLine {
				d.Decs.Before = dst.EmptyLine
			}
		case *dst.FuncDecl:
			if d.Decs.Before > dst.EmptyLine {
				d.Decs.Before = dst.EmptyLine
			}
		case *dst.Field:
			if d.Decs.Before > dst.EmptyLine {
				d.Decs.Before = dst.EmptyLine
			}
		}

		return true
	})
}

func expandOneLineFunctions(f *dst.File) {
	dst.Inspect(f, func(n dst.Node) bool {
		fn, ok := n.(*dst.FuncDecl)
		if !ok || fn.Body == nil || len(fn.Body.List) == 0 {
			return true
		}
		fn.Body.List[0].Decorations().Before = dst.NewLine

		return true
	})
}

func addSpaceBeforeReturns(f *dst.File) {
	dst.Inspect(f, func(n dst.Node) bool {
		block, ok := n.(*dst.BlockStmt)
		if !ok || len(block.List) < 2 {
			return true
		}
		for i, stmt := range block.List {
			if i == 0 {
				continue
			}
			if _, isReturn := stmt.(*dst.ReturnStmt); isReturn {
				if stmt.Decorations().Before != dst.EmptyLine {
					stmt.Decorations().Before = dst.EmptyLine
				}
			}
		}

		return true
	})
}
